## Билет 11

__Методы эвристического поиска в пространстве состояний и их оптимизация: алгоритм восхождения к вершине (Hill Climbing), лучевой поиск (Beam Search), А*-алгоритм, метод ветвей и границ (Branch and Bound). Сокращение пространства состояний__

_**Курс**: методы искуственного интеллекта, 1 семестр_

Здесь подразумеваются методы поиска пути между двумя вершинами в графе, то есть дискретное пространство состояний. Оно, вообще говоря, может быть и непрерывным, но мы это не изучали.

В исходных лекциях выделяют три задачи поиска пути в графе:
1) поиск произвольного пути в графе (вообще любого)
2) поиск "хорошего" пути, но необязательно кратчайшего
3) поиск кратчайшего пути в графе

Разберем их по порядку

__Задача__: пусть дан граф $G = (E, V)$ и две вершины $S, F \in V$, необходимо найти путь из $S$ в $F$.

---

#### British Museum

Просто ищем __все возможные__ пути $S$ в $F$ и выбираем любой :)

__Проблема__: это, очевидно, очень долго, и если в графе есть цикл, то множество всех возможных путей может быть бесконечно

__Решение__: при обходе графа нужно заходить только в те вершины, в которых мы еще не были

И мы приходим к следующим алгоритмам

---
#### Breadth и Depth fisrt search (BFS, DFS)

__Идея__: мы создаем очередь из вершин, в которую добавляем только те вершины, которых там еще не было

То, куда мы добавляем дочерние вершины, определяет вид алгоритма (BFS или DFS):


```python
queue = []
visited = []

queue.add(S)

while queue is not empty:
    x = queue.pop() # достаем вершину из начала
    visited.append(x) # добавляем в список посещенных
    y = children(x) and x not in visited # y - множество дочерних вершин х, которых нет в списке посещенных
    queue.add_first(y) # если в глубину (DFS)
    queue.add_last(y) # если в ширину (BFS)
```
В DFS мы добавляем дочерние вершины __в начало__ очереди, а в BFS - __в конец__. 

Данные алгоритмы просто обходят граф и находят произвольный путь между вершинами, совершенно необязательно оптимальный. Проблема в том, что мы добалвяем дочерние вершины в очередь в __случаном порядке__. Но можно использовать __эвристику__, чтобы искать хоть немного оптимальный путь.

---
#### Hill climbing

__Идея__: давайте возьмем DFS, но на каждом шаге будем сначала ту вершину в очередь, до которой __меньше расстояние__. Другими словами, мы будем идти в ту вершину, которая ближе всего к нам. 

Более строго, на каждом шаге алгоритма мы сначала __сортируем__ множество дочерних вершин по увеличению расстония до них, и только потом добавляем в очередь

```python
queue = []
visited = []

queue.add(S)

while queue is not empty:
    x = queue.pop() # достаем вершину из начала
    visited.append(x) # добавляем в список посещенных
    y = children(x) and x not in visited # y - множество дочерних вершин х, которых нет в списке посещенных
    y = sort(y) # сортируем по увеличению расстояния 
    queue.add_first(y) # добавляем в начало очереди
```

Очевидно, данный алгоритм не ищет кратчайший путь, но делает это умнее, чем обычный DFS.

> Также есть __Best Search First__, где мы сортируем не только дочерние вершины, а всю очередь, но в билете этого нет :)

---
**Кому интересно, почему Hill Climbing**

Сама идея алгоритма пошла из эволюцинных алгоримтов, где мы пытаемся найти максимум функции $f(x)$ __стохастически__. Алгоритм примерно такой:
1) Случайно выбираем точку x (родителя) и идем в нее
2) Случайно семплируем несколько точек в окрестности х (потомки)
3) Выбираем такого потомка, в котором значение $f(x)$ максимально и идем в 

---

---
**NOTE**

It works with almost all markdown flavours (the below blank line matters).

---

